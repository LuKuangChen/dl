// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Utilities from "./Utilities.res.mjs";
import * as PervasivesU from "rescript/lib/es6/pervasivesU.js";

var dataset = [
  {
    input: [
      true,
      true
    ],
    output: true
  },
  {
    input: [
      true,
      false
    ],
    output: false
  },
  {
    input: [
      false,
      true
    ],
    output: false
  },
  {
    input: [
      false,
      false
    ],
    output: false
  }
];

function inject(b) {
  if (b) {
    return 1.0;
  } else {
    return 0.0;
  }
}

function project(i) {
  if (i === 0.0) {
    return false;
  } else if (i === 1.0) {
    return true;
  } else {
    return PervasivesU.failwith("bad input");
  }
}

function makeInitParameters() {
  return {
          w1: Math.random() - 0.5,
          w2: Math.random() - 0.5,
          b: Math.random() - 0.5
        };
}

function displayParameter(param) {
  return "y = " + param.b.toString() + " + " + param.w1.toString() + "*x1 + " + param.w2.toString() + "*x2";
}

function layer1(x) {
  return [
          x[0] ? 1.0 : 0.0,
          x[1] ? 1.0 : 0.0
        ];
}

function layer2(param, phi) {
  return phi.b + phi.w1 * param[0] + phi.w2 * param[1];
}

function d_layer2_b(_x, _phi) {
  return 1.0;
}

function d_layer2_w1(param, _phi) {
  return Utilities.jitter(param[0]);
}

function d_layer2_w2(param, _phi) {
  return Utilities.jitter(param[1]);
}

function layer3(x) {
  return Utilities.sigmoid(x);
}

function d_layer3(x) {
  return Utilities.jitter(Utilities.d_sigmoid(x));
}

function point_loss(fact, pred) {
  return - Math.log(fact ? pred : 1.0 - pred);
}

if (point_loss(true, 1.0) !== 0.0) {
  throw {
        RE_EXN_ID: "Assert_failure",
        _1: [
          "LogicalAnd.res",
          90,
          0
        ],
        Error: new Error()
      };
}

if (point_loss(false, 0.0) !== 0.0) {
  throw {
        RE_EXN_ID: "Assert_failure",
        _1: [
          "LogicalAnd.res",
          91,
          0
        ],
        Error: new Error()
      };
}

if (point_loss(true, 0.0) !== Number.POSITIVE_INFINITY) {
  throw {
        RE_EXN_ID: "Assert_failure",
        _1: [
          "LogicalAnd.res",
          92,
          0
        ],
        Error: new Error()
      };
}

if (point_loss(false, 1.0) !== Number.POSITIVE_INFINITY) {
  throw {
        RE_EXN_ID: "Assert_failure",
        _1: [
          "LogicalAnd.res",
          93,
          0
        ],
        Error: new Error()
      };
}

function d_point_loss_pred(fact, pred) {
  return Utilities.bound(- (
              fact ? 1.0 / pred : 1.0 / (pred - 1.0)
            ));
}

function loss(parameters, dataset) {
  return Utilities.sum(dataset.map(function (param) {
                  var h1 = layer1(param.input);
                  var h2 = layer2(h1, parameters);
                  var pred = Utilities.sigmoid(h2);
                  return point_loss(param.output, pred);
                }));
}

function d_loss_parameters(parameters, dataset) {
  var ds = dataset.map(function (param) {
        var output = param.output;
        var h1 = layer1(param.input);
        var h2 = layer2(h1, parameters);
        var pred = Utilities.sigmoid(h2);
        point_loss(output, pred);
        var d_loss_pred = d_point_loss_pred(output, pred);
        var d_pred_h2 = d_layer3(h2);
        return {
                w1: Utilities.bound(d_layer2_w1(h1, parameters) * d_pred_h2 * d_loss_pred),
                w2: Utilities.bound(d_layer2_w2(h1, parameters) * d_pred_h2 * d_loss_pred),
                b: Utilities.bound(1.0 * d_pred_h2 * d_loss_pred)
              };
      });
  return {
          w1: Utilities.sum(ds.map(function (param) {
                    return param.w1;
                  })),
          w2: Utilities.sum(ds.map(function (param) {
                    return param.w2;
                  })),
          b: Utilities.sum(ds.map(function (param) {
                    return param.b;
                  }))
        };
}

function closeEnough(p1, p2) {
  return Utilities.sum([
              Math.pow(p1.b - p2.b, 2.0),
              Math.pow(p1.w1 - p2.w1, 2.0),
              Math.pow(p1.w2 - p2.w2, 2.0)
            ]) <= Number.EPSILON;
}

function learn(iteration, dataset) {
  if (!Utilities.nonnegative(iteration)) {
    PervasivesU.failwith("bad iteration");
  }
  var updateParameter = function (parameters) {
    var d = d_loss_parameters(parameters, dataset);
    return {
            w1: parameters.w1 - d.w1 * 10.0,
            w2: parameters.w2 - d.w2 * 10.0,
            b: parameters.b - d.b * 10.0
          };
  };
  var n = iteration;
  var shouldBreak = false;
  var currParameter = makeInitParameters();
  while(n >= 0 && !shouldBreak) {
    console.log(currParameter);
    console.log("Loss =", loss(currParameter, dataset));
    n = n - 1 | 0;
    var nextParameter = updateParameter(currParameter);
    if (closeEnough(currParameter, nextParameter)) {
      shouldBreak = true;
    } else {
      currParameter = nextParameter;
    }
  };
}

learn(1000, dataset);

var alpha = 10.0;

export {
  alpha ,
  dataset ,
  inject ,
  project ,
  makeInitParameters ,
  displayParameter ,
  layer1 ,
  layer2 ,
  d_layer2_b ,
  d_layer2_w1 ,
  d_layer2_w2 ,
  layer3 ,
  d_layer3 ,
  point_loss ,
  d_point_loss_pred ,
  loss ,
  d_loss_parameters ,
  closeEnough ,
  learn ,
}
/*  Not a pure module */
