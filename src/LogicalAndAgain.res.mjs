// Generated by ReScript, PLEASE EDIT WITH CARE

import * as AutoDiff from "./AutoDiff.res.mjs";
import * as Utilities from "./Utilities.res.mjs";
import * as Core__Array from "@rescript/core/src/Core__Array.res.mjs";
import * as PervasivesU from "rescript/lib/es6/pervasivesU.js";

var dataset = [
  {
    input: [
      true,
      true
    ],
    output: true
  },
  {
    input: [
      true,
      false
    ],
    output: false
  },
  {
    input: [
      false,
      true
    ],
    output: false
  },
  {
    input: [
      false,
      false
    ],
    output: false
  }
];

function inject(b) {
  if (b) {
    return 1.0;
  } else {
    return 0.0;
  }
}

function project(i) {
  if (i === 0.0) {
    return false;
  } else if (i === 1.0) {
    return true;
  } else {
    return PervasivesU.failwith("bad input");
  }
}

var MyEnv = AutoDiff.ArrayEnv({
      length: 3
    });

var MyTerm = AutoDiff.Term({
      get: MyEnv.get,
      vadd: MyEnv.vadd,
      vsub: MyEnv.vsub,
      vmul: MyEnv.vmul,
      vdiv: MyEnv.vdiv,
      eadd: MyEnv.eadd,
      esub: MyEnv.esub,
      emul: MyEnv.emul,
      ediv: MyEnv.ediv,
      constant: MyEnv.constant,
      update: MyEnv.update
    });

function makeInitParameters() {
  return [
          Math.random() - 0.5,
          Math.random() - 0.5,
          Math.random() - 0.5
        ];
}

function loss(dataset) {
  var w0 = MyTerm.ref(0);
  var w1 = MyTerm.ref(1);
  var w2 = MyTerm.ref(2);
  return MyTerm.spy(Core__Array.reduce(dataset.map(function (datum) {
                      var input = datum.input;
                      var x1 = MyTerm.spy(MyTerm.c(input[0] ? 1.0 : 0.0), "x1");
                      var x2 = MyTerm.spy(MyTerm.c(input[1] ? 1.0 : 0.0), "x2");
                      var h1 = MyTerm.$plus(MyTerm.$plus(w0, MyTerm.$star(w1, x1)), MyTerm.$star(w2, x2));
                      var h2 = MyTerm.spy(MyTerm.$slash(MyTerm.c(1.0), MyTerm.$plus(MyTerm.c(1.0), MyTerm.exp(MyTerm.$tilde$neg(h1)))), "sigmoid");
                      return MyTerm.spy(MyTerm.$tilde$neg(MyTerm.log(datum.output ? h2 : MyTerm.$neg(MyTerm.c(1.0), h2))), "loss");
                    }), MyTerm.c(0.0), MyTerm.$plus), "TOTAL LOSS");
}

function closeEnough(env1, env2) {
  return Utilities.sum(Utilities.map2((function (x, y) {
                    return Math.pow(x - y, 2.0);
                  }), env1, env2)) <= Number.EPSILON;
}

function learn(iteration, dataset) {
  if (iteration < 0) {
    throw {
          RE_EXN_ID: "Assert_failure",
          _1: [
            "LogicalAndAgain.res",
            86,
            2
          ],
          Error: new Error()
        };
  }
  var loss$1 = loss(dataset);
  var n = iteration;
  var shouldBreak = false;
  var currParameter = makeInitParameters();
  while(n >= 0 && !shouldBreak) {
    n = n - 1 | 0;
    console.log(currParameter);
    var result = loss$1(currParameter);
    var nextParameter = Utilities.map2((function (p, dp) {
            return p - dp * 1.0;
          }), currParameter, result.derivative);
    if (closeEnough(currParameter, nextParameter)) {
      shouldBreak = true;
    } else {
      currParameter = nextParameter;
    }
  };
}

learn(5, dataset);

var alpha = 1.0;

export {
  alpha ,
  dataset ,
  inject ,
  project ,
  MyEnv ,
  MyTerm ,
  makeInitParameters ,
  loss ,
  closeEnough ,
  learn ,
}
/* MyEnv Not a pure module */
