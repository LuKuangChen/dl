// Generated by ReScript, PLEASE EDIT WITH CARE

import * as AutoDiff from "./AutoDiff.res.mjs";
import * as Utilities from "./Utilities.res.mjs";
import * as Core__Array from "@rescript/core/src/Core__Array.res.mjs";
import * as PervasivesU from "rescript/lib/es6/pervasivesU.js";

var dataset = [
  {
    input: [
      true,
      true
    ],
    output: false
  },
  {
    input: [
      true,
      false
    ],
    output: true
  },
  {
    input: [
      false,
      true
    ],
    output: true
  },
  {
    input: [
      false,
      false
    ],
    output: false
  }
];

function inject(b) {
  if (b) {
    return 1.0;
  } else {
    return 0.0;
  }
}

function project(i) {
  if (i === 0.0) {
    return false;
  } else if (i === 1.0) {
    return true;
  } else {
    return PervasivesU.failwith("bad input");
  }
}

var MyEnv = AutoDiff.ArrayEnv({
      length: 9
    });

var MyTerm = AutoDiff.Term({
      get: MyEnv.get,
      vadd: MyEnv.vadd,
      vsub: MyEnv.vsub,
      vmul: MyEnv.vmul,
      vdiv: MyEnv.vdiv,
      eadd: MyEnv.eadd,
      esub: MyEnv.esub,
      emul: MyEnv.emul,
      ediv: MyEnv.ediv,
      constant: MyEnv.constant,
      update: MyEnv.update
    });

function makeInitParameters() {
  return Utilities.buildArray(9, (function (param) {
                return (Math.random() - 0.5) * 1.0;
              }));
}

function loss(dataset) {
  var parameters = Utilities.buildArray(9, MyTerm.ref);
  var w11 = parameters.slice(0, 3);
  var w12 = parameters.slice(3, 6);
  var w2 = parameters.slice(6, 9);
  return MyTerm.spy(Core__Array.reduce(dataset.map(function (datum) {
                      var input = datum.input;
                      var x = MyTerm.spy(MyTerm.c(input[0] ? 1.0 : 0.0), "x");
                      var y = MyTerm.spy(MyTerm.c(input[1] ? 1.0 : 0.0), "y");
                      var h11 = MyTerm.sigmoid(MyTerm.dotproduct([
                                MyTerm.c(1.0),
                                x,
                                y
                              ], w11));
                      var h12 = MyTerm.sigmoid(MyTerm.dotproduct([
                                MyTerm.c(1.0),
                                x,
                                y
                              ], w12));
                      var h2 = MyTerm.sigmoid(MyTerm.dotproduct([
                                MyTerm.c(1.0),
                                h11,
                                h12
                              ], w2));
                      var pred = MyTerm.spy(h2, "Pr");
                      return MyTerm.spy(MyTerm.$tilde$neg(MyTerm.log(datum.output ? pred : MyTerm.$neg(MyTerm.c(1.0), pred))), "loss");
                    }), MyTerm.c(0.0), MyTerm.$plus), "TOTAL LOSS");
}

function closeEnough(env1, env2) {
  return Utilities.sum(Utilities.map2((function (x, y) {
                    return Math.pow(x - y, 2.0);
                  }), env1, env2)) <= Number.EPSILON;
}

function learn(iteration, dataset) {
  if (iteration < 0) {
    throw {
          RE_EXN_ID: "Assert_failure",
          _1: [
            "LogicalXor.res",
            91,
            2
          ],
          Error: new Error()
        };
  }
  var loss$1 = loss(dataset);
  var n = iteration;
  var shouldBreak = false;
  var currParameter = makeInitParameters();
  while(n >= 0 && !shouldBreak) {
    n = n - 1 | 0;
    console.log(currParameter);
    var result = loss$1(currParameter);
    var nextParameter = Utilities.map2((function (p, dp) {
            return p - dp * 1.0;
          }), currParameter, result.derivative);
    if (Utilities.dotproduct(result.derivative, result.derivative) < Number.EPSILON) {
      shouldBreak = true;
    } else {
      currParameter = nextParameter;
    }
  };
}

learn(1000, dataset);

var alpha = 1.0;

var parameterCount = 9;

export {
  alpha ,
  dataset ,
  inject ,
  project ,
  parameterCount ,
  MyEnv ,
  MyTerm ,
  makeInitParameters ,
  loss ,
  closeEnough ,
  learn ,
}
/* MyEnv Not a pure module */
