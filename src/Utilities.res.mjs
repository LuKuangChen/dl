// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Caml_obj from "rescript/lib/es6/caml_obj.js";
import * as Core__Array from "@rescript/core/src/Core__Array.res.mjs";
import * as Core__Option from "@rescript/core/src/Core__Option.res.mjs";

function buildArray(length, f) {
  return Core__Array.make(length, 0.0).map(function (param, i) {
              return f(i);
            });
}

function map2(ns, ms, f) {
  if (ns.length !== ms.length) {
    throw {
          RE_EXN_ID: "Assert_failure",
          _1: [
            "Utilities.res",
            7,
            2
          ],
          Error: new Error()
        };
  }
  return ns.map(function (n, i) {
              var m = Core__Option.getExn(ms[i], undefined);
              return f(n, m);
            });
}

function bound(n) {
  if (n === Number.NEGATIVE_INFINITY) {
    return - Number.MAX_VALUE;
  } else if (n === Number.POSITIVE_INFINITY) {
    return Number.MAX_VALUE;
  } else {
    return n;
  }
}

function jitter(n) {
  if (Math.random() >= 0.5) {
    return n - Number.EPSILON;
  } else {
    return n + Number.EPSILON;
  }
}

function closeEnough(n, m) {
  return Math.pow(n - m, 2.0) < Number.EPSILON;
}

function vadd(x, y) {
  return map2(x, y, (function (x, y) {
                return x + y;
              }));
}

function vsub(x, y) {
  return map2(x, y, (function (x, y) {
                return x - y;
              }));
}

function vmul(x, y) {
  return map2(x, y, (function (x, y) {
                return x * y;
              }));
}

function vdiv(x, y) {
  return map2(x, y, (function (x, y) {
                return x / y;
              }));
}

function eadd(x, y) {
  return x.map(function (x) {
              return x + y;
            });
}

function esub(x, y) {
  return x.map(function (x) {
              return x - y;
            });
}

function emul(x, y) {
  return x.map(function (x) {
              return x * y;
            });
}

function ediv(x, y) {
  return x.map(function (x) {
              return x / y;
            });
}

function dotproduct(v1, v2) {
  return Core__Array.reduce(map2(v1, v2, (function (prim0, prim1) {
                    return prim0 * prim1;
                  })), 0.0, (function (prim0, prim1) {
                return prim0 + prim1;
              }));
}

function max(x, y) {
  if (Caml_obj.greaterequal(x, y)) {
    return x;
  } else {
    return y;
  }
}

function min(x, y) {
  if (Caml_obj.lessequal(x, y)) {
    return x;
  } else {
    return y;
  }
}

function ensurePos(x) {
  return max(x, Number.EPSILON);
}

function pow(x, exp) {
  var x$1 = bound(Math.pow(x, exp));
  return max(x$1, Number.EPSILON);
}

function exp(x) {
  var x$1 = bound(Math.exp(x));
  return max(x$1, Number.EPSILON);
}

function log(x) {
  return bound(Math.log(max(x, Number.EPSILON)));
}

var BoundMath = {
  max: max,
  min: min,
  ensurePos: ensurePos,
  pow: pow,
  exp: exp,
  log: log
};

export {
  buildArray ,
  map2 ,
  bound ,
  jitter ,
  closeEnough ,
  vadd ,
  vsub ,
  vmul ,
  vdiv ,
  eadd ,
  esub ,
  emul ,
  ediv ,
  dotproduct ,
  BoundMath ,
}
/* No side effect */
